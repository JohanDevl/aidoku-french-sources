# Diagnostic : Probl√®me de rafra√Æchissement de la biblioth√®que Aidoku

## R√©sum√© Ex√©cutif

Lors du rafra√Æchissement massif de la biblioth√®que dans Aidoku, certains mangas ne se mettent pas √† jour correctement. Ce document identifie les causes racines et propose des solutions.

**Date d'analyse** : 2025-10-14
**Contexte** : 12 sources fran√ßaises actives, ~30 mangas dans la biblioth√®que test

---

## 1. Architecture du rafra√Æchissement de biblioth√®que

### 1.1 Flux de donn√©es Aidoku iOS

```
User Pull-to-Refresh
    ‚Üì
LibraryViewController.updateLibraryRefresh()
    ‚Üì
MangaManager.refreshLibrary(category: String?)
    ‚Üì
MangaManager.doLibraryRefresh()
    ‚îÇ
    ‚îú‚îÄ‚Üí updateMangaDetails(manga: [Manga])  ‚Üê Si Library.refreshMetadata = true
    ‚îÇ   ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚Üí SourceManager.source(for: sourceId)
    ‚îÇ   ‚îÇ       ‚Üì
    ‚îÇ   ‚îÇ   Source.getMangaUpdate(needsDetails: true, needsChapters: false)
    ‚îÇ   ‚îÇ       ‚Üì
    ‚îÇ   ‚îÇ   SourceActor.getMangaDetails() ‚Üí WASM call get_manga_details
    ‚îÇ   ‚îÇ       ‚Üì
    ‚îÇ   ‚îÇ   [Parallel TaskGroup pour tous les mangas]
    ‚îÇ   ‚îÇ       ‚Üì
    ‚îÇ   ‚îî‚îÄ‚Üí CoreDataManager.update(manga) ‚Üí Database
    ‚îÇ
    ‚îî‚îÄ‚Üí [Parallel TaskGroup pour fetch chapters]
        ‚îÇ
        ‚îú‚îÄ‚Üí Source.getMangaUpdate(needsDetails: false, needsChapters: true)
        ‚îÇ       ‚Üì
        ‚îÇ   SourceActor.getChapterList() ‚Üí WASM call get_chapter_list
        ‚îÇ       ‚Üì
        ‚îî‚îÄ‚Üí CoreDataManager.setChapters() ‚Üí Database
```

### 1.2 Points cl√©s

1. **Parall√©lisation massive** : Tous les mangas sont mis √† jour en parall√®le via Swift TaskGroup
2. **Erreurs silencieuses** : `try?` utilis√© partout ‚Üí √©checs individuels ne bloquent pas le refresh global
3. **Deux phases distinctes** :
   - Phase 1 : M√©tadonn√©es (`get_manga_details` si `Library.refreshMetadata = true`)
   - Phase 2 : Chapitres (`get_chapter_list` pour tous les mangas non-skipp√©s)
4. **Pas de logging par source** : Impossible de savoir quelle source √©choue

---

## 2. Diagnostic des sources fran√ßaises

### 2.1 Compl√©tude des m√©tadonn√©es

| Source | Title | Cover | Authors | Description | Tags | Status | Chapters | Content Rating | Viewer | send_partial_result | Notes |
|--------|-------|-------|---------|-------------|------|--------|----------|----------------|--------|---------------------|-------|
| **animesama** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | Excellent |
| **fmteam** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | API stable |
| **lelmanga** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | Excellent |
| **lelscanfr** | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå | ‚ùå | ‚ùå | ‚úÖ | ‚ùå | ‚ùå | ‚úÖ | **M√©tadonn√©es minimales** |
| **mangascantrad** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | **Le plus robuste** |
| **mangasorigines** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | Excellent |
| **mangasscans** | ‚úÖ | ‚úÖ | ‚ùå | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | Author manquant |
| **phenixscans** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | API robuste |
| **poseidonscans** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | Hybrid excellent |
| **raijinscans** | ‚úÖ | ‚úÖ | ‚ùå | ‚úÖ | ‚úÖ | ‚úÖ | ‚ö†Ô∏è | ‚úÖ | ‚úÖ | ‚ùå | **chapter_number=None!** |
| **rimuscans** | ‚úÖ | ‚úÖ | ‚ùå | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå | Author hardcoded |
| **sushiscans** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | Excellent |

### 2.2 Issues critiques identifi√©es

#### üî¥ Priorit√© 1 - BLOQUANT

##### **Issue #1 : fr.raijinscans - chapter_number toujours None**

**Fichier** : `sources/fr.raijinscans/src/parser.rs:138`

**Probl√®me** :
```rust
chapter_number: None,  // ‚Üê Hardcod√© √† None !
```

**Impact** :
- Les chapitres ne peuvent pas √™tre tri√©s correctement dans l'app
- L'ordre d'affichage est al√©atoire
- Impossible de d√©tecter les nouveaux chapitres correctement

**Solution** :
```rust
// Extraire depuis le titre ou l'URL
chapter_number: extract_chapter_number(&title),
```

**Exemple de mangas affect√©s** : Kaiju No. 8, Jujutsu Kaisen (dans la capture d'√©cran)

---

##### **Issue #2 : fr.raijinscans - Code duplication massive**

**Fichier** : `sources/fr.raijinscans/src/lib.rs`

**Probl√®me** :
- ~180 lignes de parsing dupliqu√©es 3 fois
- Logique identique dans `get_manga_list`, `get_manga_details`, etc.

**Impact** :
- Maintenance difficile
- Bugs se propagent √† plusieurs endroits
- Incoh√©rences entre les fonctions

**Solution** :
```rust
// Cr√©er une fonction helper
fn parse_manga_item(node: Node) -> Result<Manga> {
    // Logique commune ici
}
```

---

##### **Issue #3 : fr.rimuscans - Filters compl√®tement d√©sactiv√©s**

**Fichier** : `sources/fr.rimuscans/res/filters.json`

**Probl√®me** :
```json
[]  // ‚Üê Fichier vide !
```

**Impact** :
- Aucune fonctionnalit√© de recherche/filtre disponible
- Exp√©rience utilisateur d√©grad√©e

**Solution** :
Impl√©menter un syst√®me de filtres basique (genre, status, etc.)

---

#### üü° Priorit√© 2 - IMPORTANT

##### **Issue #4 : fr.lelscanfr - M√©tadonn√©es minimales**

**Fichier** : `sources/fr.lelscanfr/src/lib.rs`

**Manquant** :
- `authors`
- `description`
- `tags`
- `status`
- `content_rating`
- `viewer`

**Impact** :
- Informations incompl√®tes dans la fiche manga
- Pas de filtrage par genre possible
- Pas d'indicateur de contenu mature

**Exemple de mangas affect√©s** : Leveling With the Gods, Kaguya Bachi, Sakamoto Days (dans la capture d'√©cran)

---

##### **Issue #5 : Authors manquants dans 3 sources**

**Sources** : `fr.mangasscans`, `fr.raijinscans`, `fr.rimuscans`

**Probl√®me** :
```rust
manga.author = Vec::new();  // Toujours vide
```

**Impact** :
- Information manquante dans l'app
- Impossible de rechercher par auteur

---

##### **Issue #6 : Pas d'utilisation de send_partial_result**

**Sources** : `fr.raijinscans`, `fr.rimuscans`

**Probl√®me** :
Sans `send_partial_result()`, l'app attend que TOUTES les donn√©es soient r√©cup√©r√©es avant de mettre √† jour l'UI.

**Impact potentiel** :
- Timeouts lors du rafra√Æchissement massif
- Mauvaise exp√©rience utilisateur (pas de feedback progressif)

**Solution** :
```rust
if needs_details && needs_chapters {
    send_partial_result(&manga);  // Envoyer les m√©tadonn√©es avant de fetch les chapitres
}
```

---

### 2.3 Sources de conflits potentiels

#### Conflit A : Incoh√©rence dans l'error handling

**Sources diff√©rentes, strat√©gies diff√©rentes** :

- **phenixscans** : Retry logic avec 3 tentatives
- **poseidonscans** : Fallback cascade (RSC ‚Üí __NEXT_DATA__ ‚Üí JSON-LD ‚Üí HTML)
- **raijinscans** : Propagation d'erreur imm√©diate
- **lelscanfr** : Silent fail avec donn√©es vides

**Impact** :
Lors d'un rafra√Æchissement massif, certaines sources √©chouent silencieusement tandis que d'autres bloquent.

---

#### Conflit B : Variations dans le chapter number extraction

Chaque source a sa propre logique :
- **animesama** : Parsing JavaScript avec mapping sp√©cial pour One Piece
- **fmteam** : Extraction depuis API JSON
- **lelscanfr** : Extraction depuis l'URL avec regex
- **raijinscans** : ‚ùå Pas impl√©ment√© du tout

**Impact** :
Incoh√©rences dans le tri et l'affichage des chapitres.

---

#### Conflit C : Date parsing variations

**Formats support√©s varient** :
- **sushiscans** : English + French avec extraction from title
- **mangasscans** : French + English months
- **rimuscans** : Parsing complexe (64 lignes) avec bugs potentiels
- **animesama** : Fixed dates (One Piece mappings)

**Impact** :
Dates incorrectes ou manquantes peuvent affecter l'ordre d'affichage et la d√©tection de nouveaux chapitres.

---

## 3. Solutions propos√©es

### 3.1 Pour les sources fran√ßaises (ce repo)

#### Action 1 : Ajouter des logs println dans toutes les sources

**Objectif** : Identifier quelle source cause des probl√®mes lors du refresh massif

**Pattern de logging √† impl√©menter** :

```rust
// Au d√©but de get_manga_update()
println!("[SOURCE_ID] get_manga_update START - manga: {}, needs_details: {}, needs_chapters: {}",
    manga.id, needs_details, needs_chapters);

// Apr√®s fetch des m√©tadonn√©es
if needs_details {
    println!("[SOURCE_ID] Metadata fetched successfully - title: {}", manga.title);
}

// Apr√®s fetch des chapitres
if needs_chapters {
    println!("[SOURCE_ID] Chapters fetched successfully - count: {}", chapters_count);
}

// En cas d'erreur
println!("[SOURCE_ID] ERROR - {}", error_message);

// √Ä la fin
println!("[SOURCE_ID] get_manga_update COMPLETE");
```

**Sources prioritaires pour ajout de logs** :
1. ‚úÖ fr.raijinscans (issues critiques)
2. ‚úÖ fr.rimuscans (issues critiques)
3. ‚úÖ fr.lelscanfr (m√©tadonn√©es minimales)
4. ‚úÖ fr.mangasscans (author manquant)
5. ‚úÖ Toutes les autres sources (consistency)

---

#### Action 2 : Fixes critiques prioritaires

**Fix 1 : fr.raijinscans - Impl√©menter chapter_number extraction**

```rust
// Dans parser.rs
fn extract_chapter_number(title: &str) -> Option<f32> {
    // Pattern: "Chapitre 123" ou "Chapter 123.5"
    let re = Regex::new(r"(?i)(?:chapitre|chapter|ch\.?)\s*(\d+(?:\.\d+)?)")
        .unwrap();

    if let Some(caps) = re.captures(title) {
        caps.get(1)?.as_str().parse::<f32>().ok()
    } else {
        None
    }
}

// Remplacer dans parse_chapter()
chapter_number: extract_chapter_number(&title),
```

**Fix 2 : fr.raijinscans - Refactor code duplication**

```rust
// Cr√©er helper.rs
pub fn parse_manga_item(node: Node) -> Result<Manga> {
    // Logique commune de parsing ici
}

// Utiliser dans lib.rs
let manga = parse_manga_item(node)?;
```

**Fix 3 : fr.rimuscans - Impl√©menter filters.json**

```json
[
  {
    "type": "title",
    "name": "Titre"
  },
  {
    "type": "genre",
    "name": "Genre",
    "canExclude": true,
    "options": [
      "Action", "Adventure", "Comedy", "Drama",
      "Fantasy", "Romance", "Sci-Fi", "Slice of Life"
    ]
  },
  {
    "type": "select",
    "name": "Statut",
    "options": ["Tous", "En cours", "Termin√©"]
  }
]
```

---

#### Action 3 : Standardiser send_partial_result()

**Ajouter dans toutes les sources** :

```rust
pub extern "C" fn get_manga_update(manga_id: i32) -> i32 {
    let mut manga = /* ... fetch manga ... */;

    if needs_details {
        // Fetch metadata
        manga.title = /* ... */;
        manga.cover = /* ... */;
        // ... autres champs

        if needs_chapters {
            send_partial_result(&manga);  // ‚Üê Ajouter ici
        }
    }

    if needs_chapters {
        manga.chapters = /* ... fetch chapters ... */;
    }

    Ok(manga)
}
```

**Sources √† modifier** :
- ‚úÖ fr.raijinscans
- ‚úÖ fr.rimuscans

---

#### Action 4 : Compl√©ter les m√©tadonn√©es manquantes

**fr.lelscanfr** - Ajouter parsing de m√©tadonn√©es :

```rust
// Dans get_manga_update()
if needs_details {
    // Ajouter parsing de :
    manga.author = /* extract from HTML */;
    manga.description = /* extract synopsis */;
    manga.tags = /* extract genres */;
    manga.status = /* extract status */;
    manga.content_rating = /* calculate from tags */;
    manga.viewer = /* RightToLeft par d√©faut pour manga FR */;
}
```

**fr.mangasscans, fr.raijinscans, fr.rimuscans** - Ajouter author extraction :

```rust
// Essayer d'extraire depuis les metadata du site
manga.author = html
    .select(".manga-author")
    .text()
    .read()
    .split(',')
    .map(|s| s.trim().to_string())
    .collect();
```

---

### 3.2 Code de r√©f√©rence : Bonne impl√©mentation

**Source exemplaire** : `fr.mangascantrad` (v45)

```rust
pub extern "C" fn get_manga_update(manga_id: i32) -> i32 {
    // 1. Fetch manga page
    let url = format!("{}/manga/{}/", BASE_URL, manga.id);
    let html = Request::get(&url)
        .header("User-Agent", USER_AGENT)
        .html()?;

    // 2. Extract metadata if needed
    if needs_details {
        manga.title = html.select(".post-title h1").text().read();
        manga.cover = html.select(".summary_image img").attr("data-src").read();
        manga.description = html.select(".summary__content p").text().read();

        manga.author = html
            .select(".author-content a")
            .array()
            .map(|node| node.text().read())
            .collect();

        manga.tags = html
            .select(".genres-content a")
            .array()
            .map(|node| node.text().read())
            .collect();

        manga.status = match html.select(".post-status .summary-content").text().read().as_str() {
            s if s.contains("En cours") => MangaStatus::Ongoing,
            s if s.contains("Termin√©") => MangaStatus::Completed,
            _ => MangaStatus::Unknown,
        };

        manga.content_rating = calculate_content_rating(&manga.tags);
        manga.viewer = MangaViewer::RightToLeft;

        // 3. Send partial result before chapters
        if needs_chapters {
            println!("[mangascantrad] Metadata fetched - sending partial result");
            send_partial_result(&manga);
        }
    }

    // 4. Extract chapters if needed
    if needs_chapters {
        let chapters = extract_chapters(&html, &manga.id)?;
        manga.chapters = chapters;
        println!("[mangascantrad] Chapters fetched - count: {}", manga.chapters.len());
    }

    println!("[mangascantrad] get_manga_update COMPLETE");
    Ok(manga)
}
```

**Points cl√©s** :
1. ‚úÖ M√©tadonn√©es compl√®tes
2. ‚úÖ `send_partial_result()` utilis√© correctement
3. ‚úÖ Error handling robuste
4. ‚úÖ Logs pour debugging
5. ‚úÖ Code clean et maintenable

---

## 4. Plan de migration et tests

### 4.1 Ordre de priorit√©

**Phase 1 : Fixes critiques (Semaine 1)**
1. ‚úÖ Ajouter logs dans toutes les sources
2. ‚úÖ Fix fr.raijinscans chapter_number
3. ‚úÖ Refactor fr.raijinscans duplication
4. ‚úÖ Impl√©menter filters dans fr.rimuscans

**Phase 2 : M√©tadonn√©es (Semaine 2)**
5. ‚úÖ Compl√©ter m√©tadonn√©es fr.lelscanfr
6. ‚úÖ Ajouter author dans fr.mangasscans, fr.raijinscans, fr.rimuscans
7. ‚úÖ Standardiser send_partial_result dans toutes les sources

**Phase 3 : Harmonisation (Semaine 3)**
8. ‚úÖ Harmoniser error handling patterns
9. ‚úÖ Simplifier date parsing fr.rimuscans
10. ‚úÖ Documentation des patterns utilis√©s

---

### 4.2 Checklist de validation

Pour chaque source modifi√©e :

```bash
# 1. Build
cd sources/fr.SOURCE_NAME
aidoku package

# 2. Verify
aidoku verify package.aix

# 3. Test dans l'app
# - Ajouter un manga √† la biblioth√®que
# - Pull-to-refresh
# - V√©rifier les logs dans Xcode console
# - V√©rifier que les m√©tadonn√©es s'affichent
# - V√©rifier que les chapitres sont tri√©s correctement
```

**Logs attendus** :
```
[SOURCE_ID] get_manga_update START - manga: some_id, needs_details: true, needs_chapters: true
[SOURCE_ID] Metadata fetched successfully - title: Manga Title
[SOURCE_ID] Chapters fetched successfully - count: 123
[SOURCE_ID] get_manga_update COMPLETE
```

**En cas d'erreur** :
```
[SOURCE_ID] ERROR - Failed to fetch manga page: 404
```

---

### 4.3 Tests de non-r√©gression

Apr√®s tous les fixes, tester le sc√©nario complet :

1. **Setup** :
   - Ajouter 3-5 mangas de chaque source dans la biblioth√®que
   - Total : ~30-40 mangas

2. **Test de rafra√Æchissement massif** :
   - Pull-to-refresh sur la biblioth√®que
   - Observer les logs dans la console
   - V√©rifier qu'aucune source ne bloque
   - V√©rifier que toutes les m√©tadonn√©es sont √† jour

3. **V√©rifications** :
   - ‚úÖ Toutes les couvertures s'affichent
   - ‚úÖ Tous les titres sont corrects
   - ‚úÖ Les chapitres sont tri√©s correctement
   - ‚úÖ Les badges de nouveaux chapitres sont corrects
   - ‚úÖ Pas de timeouts ou crashes
   - ‚úÖ Logs clairs pour chaque source

4. **Tests de cas limites** :
   - Source indisponible (timeout)
   - Manga supprim√© du site
   - Site en maintenance
   - Rate limiting

---

## 5. Conclusion

### Points forts actuels
- ‚úÖ Architecture iOS solide avec parall√©lisation efficace
- ‚úÖ 8/12 sources ont des impl√©mentations compl√®tes et robustes
- ‚úÖ Bonnes pratiques de parsing avec fallbacks
- ‚úÖ Support bilingual (French + English) dans plusieurs sources

### Points √† am√©liorer
- ‚ùå 2 sources avec bugs critiques (raijinscans, rimuscans)
- ‚ùå Manque de logging pour debugging
- ‚ùå Inconsistance dans l'utilisation de send_partial_result
- ‚ùå M√©tadonn√©es incompl√®tes dans certaines sources

### Impact attendu apr√®s fixes
- üéØ Rafra√Æchissement plus fiable avec moins d'√©checs silencieux
- üéØ Meilleur feedback utilisateur avec logs clairs
- üéØ Tri des chapitres correct pour tous les mangas
- üéØ M√©tadonn√©es compl√®tes dans toutes les sources
- üéØ Base de code plus maintenable et coh√©rente

---

## Annexes

### A. Statistiques du projet

- **Sources actives** : 12
- **Sources offline** : 5
- **Templates** : 3 (madara, mangastream, mmrcms)
- **Total lignes de code** : ~5000+ (estimation)
- **Build target** : wasm32-unknown-unknown

### B. R√©f√©rences

- [Aidoku iOS App Repository](https://github.com/Aidoku/Aidoku)
- [Aidoku Community Sources](https://github.com/Skittyblock/aidoku-community-sources)
- [Aidoku-rs Documentation](https://aidoku.github.io/aidoku-rs/aidoku/index.html)

### C. Contacts et support

- **GitHub Issues** : https://github.com/Aidoku/Aidoku/issues
- **Community Discord** : https://discord.gg/9U8cC5Z

---

**Document cr√©√© le** : 2025-10-14
**Derni√®re mise √† jour** : 2025-10-14
**Version** : 1.0
